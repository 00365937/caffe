PROJECT := caffe\n\nCONFIG_FILE := Makefile.config\ninclude $(CONFIG_FILE)\n\nCXXFLAGS += -std=c++11 -Wno-deprecated-declarations\nLINKFLAGS += -std=c++11 -Wno-deprecated-declarations\nNVCCFLAGS += -Xcompiler "-Wno-deprecated-declarations" -Xlinker "-Wno-deprecated-declarations" -Xarchive "-Wno-deprecated-declarations" -Xnvlink "-Wno-deprecated-declarations"\n\nBUILD_DIR_LINK := $(BUILD_DIR)\nRELEASE_BUILD_DIR ?= .$(BUILD_DIR)_release\nDEBUG_BUILD_DIR ?= .$(BUILD_DIR)_debug\n\nDEBUG ?= 0\nifeq ($(DEBUG), 1)\n	BUILD_DIR := $(DEBUG_BUILD_DIR)\n	OTHER_BUILD_DIR := $(RELEASE_BUILD_DIR)\nelse\n	BUILD_DIR := $(RELEASE_BUILD_DIR)\n	OTHER_BUILD_DIR := $(DEBUG_BUILD_DIR)\nendif\n\n\n# All of the directories containing code.\nSRC_DIRS := $(shell find * -type d -exec bash -c "find {} -maxdepth 1 \\n	\( -name '*.cpp' -o -name '*.proto' \) | grep -q ." \; -print)\n\n# The target shared library name\nLIB_BUILD_DIR := $(BUILD_DIR)/lib\nSTATIC_NAME := $(LIB_BUILD_DIR)/lib$(PROJECT).a\nDYNAMIC_NAME := $(LIB_BUILD_DIR)/lib$(PROJECT).so\n\n##############################\n# Get all source files\n##############################\n# CXX_SRCS are the source files excluding the test ones.\nCXX_SRCS := $(shell find src/$(PROJECT) ! -name "test_*.cpp" -name "*.cpp")\n# CU_SRCS are the cuda source files\nCU_SRCS := $(shell find src/$(PROJECT) ! -name "test_*.cu" -name "*.cu")\n# TEST_SRCS are the test source files\nTEST_MAIN_SRC := src/$(PROJECT)/test/test_caffe_main.cpp\nTEST_SRCS := $(shell find src/$(PROJECT) -name "test_*.cpp")\nTEST_SRCS := $(filter-out $(TEST_MAIN_SRC), $(TEST_SRCS))\nTEST_CU_SRCS := $(shell find src/$(PROJECT) -name "test_*.cu")\nGTEST_SRC := src/gtest/gtest-all.cpp\n# TOOL_SRCS are the source files for the tool binaries\nTOOL_SRCS := $(shell find tools -name "*.cpp")\n# EXAMPLE_SRCS are the source files for the example binaries\nEXAMPLE_SRCS := $(shell find examples -name "*.cpp")\n# BUILD_INCLUDE_DIR contains any generated header files we want to include.\nBUILD_INCLUDE_DIR := $(BUILD_DIR)/src\n# PROTO_SRCS are the protocol buffer definitions\nPROTO_SRC_DIR := src/$(PROJECT)/proto\nPROTO_SRCS := $(wildcard $(PROTO_SRC_DIR)/*.proto)\n# PROTO_BUILD_DIR will contain the .cc and obj files generated from\n# PROTO_SRCS; PROTO_BUILD_INCLUDE_DIR will contain the .h header files\nPROTO_BUILD_DIR := $(BUILD_DIR)/$(PROTO_SRC_DIR)\nPROTO_BUILD_INCLUDE_DIR := $(BUILD_INCLUDE_DIR)/$(PROJECT)/proto\n# NONGEN_CXX_SRCS includes all source/header files except those generated\n# automatically (e.g., by proto).\nNONGEN_CXX_SRCS := $(shell find \\n	src/$(PROJECT) \\n	include/$(PROJECT) \\n	python/$(PROJECT) \\n	matlab/$(PROJECT) \\n	examples \\n	tools \\n	-name "*.cpp" -or -name "*.hpp" -or -name "*.cu" -or -name "*.cuh")\nLINT_SCRIPT := scripts/cpp_lint.py\nLINT_OUTPUT_DIR := $(BUILD_DIR)/.lint\nLINT_EXT := lint.txt\nLINT_OUTPUTS := $(addsuffix .$(LINT_EXT), $(addprefix $(LINT_OUTPUT_DIR)/, $(NONGEN_CXX_SRCS)))\nEMPTY_LINT_REPORT := $(BUILD_DIR)/.$(LINT_EXT)\nNONEMPTY_LINT_REPORT := $(BUILD_DIR)/$(LINT_EXT)\n# PY$(PROJECT)_SRC is the python wrapper for $(PROJECT)\nPY$(PROJECT)_SRC := python/$(PROJECT)/_$(PROJECT).cpp\nPY$(PROJECT)_SO := python/$(PROJECT)/_$(PROJECT).so\nPY$(PROJECT)_HXX := include/$(PROJECT)/python_layer.hpp\n# MAT$(PROJECT)_SRC is the matlab wrapper for $(PROJECT)\nMAT$(PROJECT)_SRC := matlab/$(PROJECT)/mat$(PROJECT).cpp\nifneq ($(MATLAB_DIR),)\n	MAT_SO_EXT := $(shell $(MATLAB_DIR)/bin/mexext)\nendif\nMAT$(PROJECT)_SO := matlab/$(PROJECT)/$(PROJECT).$(MAT_SO_EXT)\n\n##############################\n# Derive generated files\n##############################\n# The generated files for protocol buffers\nPROTO_GEN_HEADER_SRCS := $(addprefix $(PROTO_BUILD_DIR)/, \\n		$(notdir ${PROTO_SRCS:.proto=.pb.h}))\nPROTO_GEN_HEADER := $(addprefix $(PROTO_BUILD_INCLUDE_DIR)/, \\n		$(notdir ${PROTO_SRCS:.proto=.pb.h}))\nPROTO_GEN_CC := $(addprefix $(BUILD_DIR)/, ${PROTO_SRCS:.proto=.pb.cc})\nPY_PROTO_BUILD_DIR := python/$(PROJECT)/proto\nPY_PROTO_INIT := python/$(PROJECT)/proto/__init__.py\nPROTO_GEN_PY := $(foreach file,${PROTO_SRCS:.proto=_pb2.py}, \\n		$(PY_PROTO_BUILD_DIR)/$(notdir $(file)))\n# The objects corresponding to the source files\n# These objects will be linked into the final shared library, so we\n# exclude the tool, example, and test objects.\nCXX_OBJS := $(addprefix $(BUILD_DIR)/, ${CXX_SRCS:.cpp=.o})\nCU_OBJS := $(addprefix $(BUILD_DIR)/cuda/, ${CU_SRCS:.cu=.o})\nPROTO_OBJS := ${PROTO_GEN_CC:.cc=.o}\nOBJS := $(PROTO_OBJS) $(CXX_OBJS) $(CU_OBJS)\n# tool, example, and test objects\nTOOL_OBJS := $(addprefix $(BUILD_DIR)/, ${TOOL_SRCS:.cpp=.o})\nTOOL_BUILD_DIR := $(BUILD_DIR)/tools\nTEST_CXX_BUILD_DIR := $(BUILD_DIR)/src/$(PROJECT)/test\nTEST_CU_BUILD_DIR := $(BUILD_DIR)/cuda/src/$(PROJECT)/test\nTEST_CXX_OBJS := $(addprefix $(BUILD_DIR)/, ${TEST_SRCS:.cpp=.o})\nTEST_CU_OBJS := $(addprefix $(BUILD_DIR)/cuda/, ${TEST_CU_SRCS:.cu=.o})\nTEST_OBJS := $(TEST_CXX_OBJS) $(TEST_CU_OBJS)\nGTEST_OBJ := $(addprefix $(BUILD_DIR)/, ${GTEST_SRC:.cpp=.o})\nEXAMPLE_OBJS := $(addprefix $(BUILD_DIR)/, ${EXAMPLE_SRCS:.cpp=.o})\n# Output files for automatic dependency generation\nDEPS := ${CXX_OBJS:.o=.d} ${CU_OBJS:.o=.d} ${TEST_CXX_OBJS:.o=.d} \\n	${TEST_CU_OBJS:.o=.d}\n# tool, example, and test bins\nTOOL_BINS := ${TOOL_OBJS:.o=.bin}\nEXAMPLE_BINS := ${EXAMPLE_OBJS:.o=.bin}\n# symlinks to tool bins without the ".bin" extension\nTOOL_BIN_LINKS := ${TOOL_BINS:.bin=}\n# Put the test binaries in build/test for convenience.\nTEST_BIN_DIR := $(BUILD_DIR)/test\nTEST_CU_BINS := $(addsuffix .testbin,$(addprefix $(TEST_BIN_DIR)/, \\n		$(foreach obj,$(TEST_CU_OBJS),$(basename $(notdir $(obj))))))\nTEST_CXX_BINS := $(addsuffix .testbin,$(addprefix $(TEST_BIN_DIR)/, \\n		$(foreach obj,$(TEST_CXX_OBJS),$(basename $(notdir $(obj))))))\nTEST_BINS := $(TEST_CXX_BINS) $(TEST_CU_BINS)\n# TEST_ALL_BIN is the test binary that links caffe dynamically.\nTEST_ALL_BIN := $(TEST_BIN_DIR)/test_all.testbin\n\n##############################\n# Derive compiler warning dump locations\n##############################\nWARNS_EXT := warnings.txt\nCXX_WARNS := $(addprefix $(BUILD_DIR)/, ${CXX_SRCS:.cpp=.o.$(WARNS_EXT)})\nCU_WARNS := $(addprefix $(BUILD_DIR)/cuda/, ${CU_SRCS:.cu=.o.$(WARNS_EXT)})\nTOOL_WARNS := $(addprefix $(BUILD_DIR)/, ${TOOL_SRCS:.cpp=.o.$(WARNS_EXT)})\nEXAMPLE_WARNS := $(addprefix $(BUILD_DIR)/, ${EXAMPLE_SRCS:.cpp=.o.$(WARNS_EXT)})\nTEST_WARNS := $(addprefix $(BUILD_DIR)/, ${TEST_SRCS:.cpp=.o.$(WARNS_EXT)})\nTEST_CU_WARNS := $(addprefix $(BUILD_DIR)/cuda/, ${TEST_CU_SRCS:.cu=.o.$(WARNS_EXT)})\nALL_CXX_WARNS := $(CXX_WARNS) $(TOOL_WARNS) $(EXAMPLE_WARNS) $(TEST_WARNS)\nALL_CU_WARNS := $(CU_WARNS) $(TEST_CU_WARNS)\nALL_WARNS := $(ALL_CXX_WARNS) $(ALL_CU_WARNS)\n\nEMPTY_WARN_REPORT := $(BUILD_DIR)/.$(WARNS_EXT)\nNONEMPTY_WARN_REPORT := $(BUILD_DIR)/$(WARNS_EXT)\n\n##############################\n# GreenTea backend related include and lib\n##############################\n\nifeq ($(USE_GREENTEA),1)\n	# Find a valid OpenCL library\n	ifdef OPENCL_INC\n		CLLINC = '$(OPENCL_INC)'\n	endif\n	\n	ifdef OPENCL_LIB\n		CLLIBS = '$(OPENCL_LIB)'\n	endif\n	\n	ifdef OPENCLROOT\n		CLLIBS = '$(OPENCLROOT)'\n	endif\n	\n	ifdef CUDA_PATH\n		CLLIBS = '$(CUDA_PATH)/lib/x64'\n	endif\n	\n	ifdef INTELOCLSDKROOT\n		CLLIBS = '$(INTELOCLSDKROOT)/lib/x64'\n	endif\n	\n	ifdef AMDAPPSDKROOT\n		CLLIBS = '$(AMDAPPSDKROOT)/lib/x86_64'\n		CLLINC = '$(AMDAPPSDKROOT)/include'\n	endif\n	# Requires valid OpenCL library\n	LIBRARY_DIRS += $(CLLIBS)\n	# Requires valid OpenCL headers and valid ViennaCL\n	INCLUDE_DIRS += $(CLLINC) $(VIENNACL_DIR)\n	# Requires OpenCL compile library flag and librt\n	LIBRARIES += OpenCL rt\n	# Additional flags\n	COMMON_FLAGS += -DUSE_GREENTEA\nendif\n\n##############################\n# Derive include and lib directories\n##############################\nCUDA_INCLUDE_DIR := $(CUDA_DIR)/include\n\nCUDA_LIB_DIR :=\n# add <cuda>/lib64 only if it exists\nifneq ("$(wildcard $(CUDA_DIR)/lib64)","")\n	CUDA_LIB_DIR += $(CUDA_DIR)/lib64\nendif\nCUDA_LIB_DIR += $(CUDA_DIR)/lib\n\nINCLUDE_DIRS += $(BUILD_INCLUDE_DIR) ./src ./include\nifneq ($(CPU_ONLY), 1)\n	INCLUDE_DIRS += $(CUDA_INCLUDE_DIR)\n	LIBRARY_DIRS += $(CUDA_LIB_DIR)\n	LIBRARIES += cudart cublas curand\nendif\nLIBRARIES += glog gflags protobuf leveldb snappy \\n	lmdb boost_system hdf5_hl hdf5 m \\n	opencv_core opencv_highgui opencv_imgproc\nPYTHON_LIBRARIES := boost_python python2.7\nWARNINGS := -Wall -Wno-sign-compare\n\n##############################\n# Set build directories\n##############################\n\nDISTRIBUTE_SUBDIRS := $(DISTRIBUTE_DIR)/bin $(DISTRIBUTE_DIR)/lib\nDIST_ALIASES := dist\nifneq ($(strip $(DISTRIBUTE_DIR)),distribute)\n		DIST_ALIASES += distribute\nendif\n\nALL_BUILD_DIRS := $(sort $(BUILD_DIR) $(addprefix $(BUILD_DIR)/, $(SRC_DIRS)) \\n	$(addprefix $(BUILD_DIR)/cuda/, $(SRC_DIRS)) \\n	$(LIB_BUILD_DIR) $(TEST_BIN_DIR) $(PY_PROTO_BUILD_DIR) $(LINT_OUTPUT_DIR) \\n	$(DISTRIBUTE_SUBDIRS) $(PROTO_BUILD_INCLUDE_DIR))\n\n##############################\n# Set directory for Doxygen-generated documentation\n##############################\nDOXYGEN_CONFIG_FILE ?= ./.Doxyfile\n# should be the same as OUTPUT_DIRECTORY in the .Doxyfile\nDOXYGEN_OUTPUT_DIR ?= ./doxygen\nDOXYGEN_COMMAND ?= doxygen\n# All the files that might have Doxygen documentation.\nDOXYGEN_SOURCES := $(shell find \\n	src/$(PROJECT) \\n	include/$(PROJECT) \\n	python/ \\n	matlab/ \\n	examples \\n	tools \\n	-name "*.cpp" -or -name "*.hpp" -or -name "*.cu" -or -name "*.cuh" -or \\n        -name "*.py" -or -name "*.m")\nDOXYGEN_SOURCES += $(DOXYGEN_CONFIG_FILE)\n\n\n##############################\n# Configure build\n##############################\n\n# Determine platform\nUNAME := $(shell uname -s)\nifeq ($(UNAME), Linux)\n	LINUX := 1\nelse ifeq ($(UNAME), Darwin)\n	OSX := 1\nendif\n\n# Linux\nifeq ($(LINUX), 1)\n	CXX ?= /usr/bin/g++\n	GCCVERSION := $(shell $(CXX) -dumpversion | cut -f1,2 -d.)\n	# older versions of gcc are too dumb to build boost with -Wuninitalized\n	ifeq ($(shell echo $(GCCVERSION) \< 4.6 | bc), 1)\n		WARNINGS += -Wno-uninitialized\n	endif\n	# boost::thread is reasonably called boost_thread (compare OS X)\n	# We will also explicitly add stdc++ to the link target.\n	LIBRARIES += boost_thread stdc++\nendif\n\n# OS X:\n# clang++ instead of g++\n# libstdc++ for NVCC compatibility on OS X >= 10.9 with CUDA < 7.0\nifeq ($(OSX), 1)\n	CXX := /usr/bin/clang++\n	CUDA_VERSION := $(shell $(CUDA_DIR)/bin/nvcc -V | grep -o 'release \d' | grep -o '\d')\n	ifeq ($(shell echo $(CUDA_VERSION) \< 7.0 | bc), 1)\n		CXXFLAGS += -stdlib=libstdc++\n		LINKFLAGS += -stdlib=libstdc++\n	endif\n	# clang throws this warning for cuda headers\n	WARNINGS += -Wno-unneeded-internal-declaration\n	# gtest needs to use its own tuple to not conflict with clang\n	COMMON_FLAGS += -DGTEST_USE_OWN_TR1_TUPLE=1\n	# boost::thread is called boost_thread-mt to mark multithreading on OS X\n	LIBRARIES += boost_thread-mt\n	# we need to explicitly ask for the rpath to be obeyed\n	DYNAMIC_FLAGS := -install_name @rpath/libcaffe.so\n	ORIGIN := @loader_path\nelse\n	ORIGIN := \$$ORIGIN\nendif\n\n# Custom compiler\nifdef CUSTOM_CXX\n	CXX := $(CUSTOM_CXX)\nendif\n\n# Static linking\nifneq (,$(findstring clang++,$(CXX)))\n	STATIC_LINK_COMMAND := -Wl,-force_load $(STATIC_NAME)\nelse ifneq (,$(findstring g++,$(CXX)))\n	STATIC_LINK_COMMAND := -Wl,--whole-archive $(STATIC_NAME) -Wl,--no-whole-archive\nelse\n  # The following line must not be indented with a tab, since we are not inside a target\n  $(error Cannot static link with the $(CXX) compiler)\nendif\n\n# Debugging\nifeq ($(DEBUG), 1)\n	COMMON_FLAGS += -DDEBUG -g -O0\n	NVCCFLAGS += -G\nelse\n	COMMON_FLAGS += -DNDEBUG -O2\nendif\n\n# cuDNN acceleration configuration.\nifeq ($(USE_CUDNN), 1)\n	LIBRARIES += cudnn\n	COMMON_FLAGS += -DUSE_CUDNN\nendif\n\n# CPU-only configuration\nifeq ($(CPU_ONLY), 1)\n	OBJS := $(PROTO_OBJS) $(CXX_OBJS)\n	TEST_OBJS := $(TEST_CXX_OBJS)\n	TEST_BINS := $(TEST_CXX_BINS)\n	ALL_WARNS := $(ALL_CXX_WARNS)\n	TEST_FILTER := --gtest_filter="-*GPU*"\n	COMMON_FLAGS += -DCPU_ONLY\nendif\n\n# Python layer support\nifeq ($(WITH_PYTHON_LAYER), 1)\n	COMMON_FLAGS += -DWITH_PYTHON_LAYER\n	LIBRARIES += $(PYTHON_LIBRARIES)\nendif\n\n# BLAS configuration (default = ATLAS)\nBLAS ?= atlas\nifeq ($(BLAS), mkl)\n	# MKL\n	LIBRARIES += mkl_rt\n	COMMON_FLAGS += -DUSE_MKL\n	MKL_DIR ?= /opt/intel/mkl\n	BLAS_INCLUDE ?= $(MKL_DIR)/include\n	BLAS_LIB ?= $(MKL_DIR)/lib $(MKL_DIR)/lib/intel64\nelse ifeq ($(BLAS), open)\n	# OpenBLAS\n	LIBRARIES += openblas\nelse\n	# ATLAS\n	ifeq ($(LINUX), 1)\n		ifeq ($(BLAS), atlas)\n			# Linux simply has cblas and atlas\n			LIBRARIES += cblas atlas\n		endif\n	else ifeq ($(OSX), 1)\n		# OS X packages atlas as the vecLib framework\n		LIBRARIES += cblas\n		# 10.10 has accelerate while 10.9 has veclib\n		XCODE_CLT_VER := $(shell pkgutil --pkg-info=com.apple.pkg.CLTools_Executables | grep -o 'version: 6')\n		ifneq (,$(findstring version: 6,$(XCODE_CLT_VER)))\n			BLAS_INCLUDE ?= /System/Library/Frameworks/Accelerate.framework/Versions/Current/Frameworks/vecLib.framework/Headers/\n			LDFLAGS += -framework Accelerate\n		else\n			BLAS_INCLUDE ?= /System/Library/Frameworks/vecLib.framework/Versions/Current/Headers/\n			LDFLAGS += -framework vecLib\n		endif\n	endif\nendif\nINCLUDE_DIRS += $(BLAS_INCLUDE)\nLIBRARY_DIRS += $(BLAS_LIB)\n\nLIBRARY_DIRS += $(LIB_BUILD_DIR)\n\n# Automatic dependency generation (nvcc is handled separately)\nCXXFLAGS += -MMD -MP\n\n# Complete build flags.\nCOMMON_FLAGS += $(foreach includedir,$(INCLUDE_DIRS),-I$(includedir))\nCXXFLAGS += -pthread -fPIC $(COMMON_FLAGS) $(WARNINGS)\nNVCCFLAGS += -ccbin=$(CXX) -Xcompiler -fPIC $(COMMON_FLAGS)\n# mex may invoke an older gcc that is too liberal with -Wuninitalized\nMATLAB_CXXFLAGS := $(CXXFLAGS) -Wno-uninitialized\nLINKFLAGS += -pthread -fPIC $(COMMON_FLAGS) $(WARNINGS)\n\nUSE_PKG_CONFIG ?= 0\nifeq ($(USE_PKG_CONFIG), 1)\n	PKG_CONFIG := $(shell pkg-config opencv --libs)\nelse\n	PKG_CONFIG :=\nendif\nLDFLAGS += $(foreach librarydir,$(LIBRARY_DIRS),-L$(librarydir)) $(PKG_CONFIG) \\n		$(foreach library,$(LIBRARIES),-l$(library))\nPYTHON_LDFLAGS := $(LDFLAGS) $(foreach library,$(PYTHON_LIBRARIES),-l$(library))\n\n# 'superclean' target recursively* deletes all files ending with an extension\n# in $(SUPERCLEAN_EXTS) below.  This may be useful if you've built older\n# versions of Caffe that do not place all generated files in a location known\n# to the 'clean' target.\n#\n# 'supercleanlist' will list the files to be deleted by make superclean.\n#\n# * Recursive with the exception that symbolic links are never followed, per the\n# default behavior of 'find'.\nSUPERCLEAN_EXTS := .so .a .o .bin .testbin .pb.cc .pb.h _pb2.py .cuo\n\n# Set the sub-targets of the 'everything' target.\nEVERYTHING_TARGETS := all py$(PROJECT) test warn lint\n# Only build matcaffe as part of "everything" if MATLAB_DIR is specified.\nifneq ($(MATLAB_DIR),)\n	EVERYTHING_TARGETS += mat$(PROJECT)\nendif\n\n##############################\n# Define build targets\n##############################\n.PHONY: all test clean docs linecount lint lintclean tools examples $(DIST_ALIASES) \\n	py mat py$(PROJECT) mat$(PROJECT) proto runtest \\n	superclean supercleanlist supercleanfiles warn everything\n\nall: clkernels $(STATIC_NAME) $(DYNAMIC_NAME) tools examples\n\neverything: $(EVERYTHING_TARGETS)\n\nlinecount:\n	cloc --read-lang-def=$(PROJECT).cloc \\n		src/$(PROJECT) include/$(PROJECT) tools examples \\n		python matlab\n\nlint: $(EMPTY_LINT_REPORT)\n\nlintclean:\n	@ $(RM) -r $(LINT_OUTPUT_DIR) $(EMPTY_LINT_REPORT) $(NONEMPTY_LINT_REPORT)\n\ndocs: $(DOXYGEN_OUTPUT_DIR)\n	@ cd ./docs ; ln -sfn ../$(DOXYGEN_OUTPUT_DIR)/html doxygen\n\n$(DOXYGEN_OUTPUT_DIR): $(DOXYGEN_CONFIG_FILE) $(DOXYGEN_SOURCES)\n	$(DOXYGEN_COMMAND) $(DOXYGEN_CONFIG_FILE)\n\n$(EMPTY_LINT_REPORT): $(LINT_OUTPUTS) | $(BUILD_DIR)\n	@ cat $(LINT_OUTPUTS) > $@\n	@ if [ -s "$@" ]; then \\n		cat $@; \\n		mv $@ $(NONEMPTY_LINT_REPORT); \\n		echo "Found one or more lint errors."; \\n		exit 1; \\n	  fi; \\n	  $(RM) $(NONEMPTY_LINT_REPORT); \\n	  echo "No lint errors!";\n\n$(LINT_OUTPUTS): $(LINT_OUTPUT_DIR)/%.lint.txt : % $(LINT_SCRIPT) | $(LINT_OUTPUT_DIR)\n	@ mkdir -p $(dir $@)\n	@ python $(LINT_SCRIPT) $< 2>&1 \\n		| grep -v "^Done processing " \\n		| grep -v "^Total errors found: 0" \\n		> $@ \\n		|| true\n\ntest: $(TEST_ALL_BIN) $(TEST_ALL_DYNLINK_BIN) $(TEST_BINS)\n\ntools: $(TOOL_BINS) $(TOOL_BIN_LINKS)\n\nexamples: $(EXAMPLE_BINS)\n\npy$(PROJECT): py\n\npy: $(PY$(PROJECT)_SO) $(PROTO_GEN_PY)\n\n$(PY$(PROJECT)_SO): $(PY$(PROJECT)_SRC) $(PY$(PROJECT)_HXX) | $(DYNAMIC_NAME)\n	@ echo CXX/LD -o $@ $<\n	$(Q)$(CXX) -shared -o $@ $(PY$(PROJECT)_SRC) \\n		-o $@ $(LINKFLAGS) -l$(PROJECT) $(PYTHON_LDFLAGS) \\n		-Wl,-rpath,$(ORIGIN)/../../build/lib\n\nmat$(PROJECT): mat\n\nmat: $(MAT$(PROJECT)_SO)\n\n$(MAT$(PROJECT)_SO): $(MAT$(PROJECT)_SRC) $(STATIC_NAME)\n	@ if [ -z "$(MATLAB_DIR)" ]; then \\n		echo "MATLAB_DIR must be specified in $(CONFIG_FILE)" \\n			"to build mat$(PROJECT)."; \\n		exit 1; \\n	fi\n	@ echo MEX $<\n	$(Q)$(MATLAB_DIR)/bin/mex $(MAT$(PROJECT)_SRC) \\n			CXX="$(CXX)" \\n			CXXFLAGS="\$$CXXFLAGS $(MATLAB_CXXFLAGS)" \\n			CXXLIBS="\$$CXXLIBS $(STATIC_LINK_COMMAND) $(LDFLAGS)" -output $@\n\nruntest: $(TEST_ALL_BIN)\n	$(TOOL_BUILD_DIR)/caffe\n	$(TEST_ALL_BIN) $(TEST_GPUID) --gtest_shuffle $(TEST_FILTER)\n\npytest: py\n	cd python; python -m unittest discover -s caffe/test\n\nwarn: $(EMPTY_WARN_REPORT)\n\n$(EMPTY_WARN_REPORT): $(ALL_WARNS) | $(BUILD_DIR)\n	@ cat $(ALL_WARNS) > $@\n	@ if [ -s "$@" ]; then \\n		cat $@; \\n		mv $@ $(NONEMPTY_WARN_REPORT); \\n		echo "Compiler produced one or more warnings."; \\n		exit 1; \\n	  fi; \\n	  $(RM) $(NONEMPTY_WARN_REPORT); \\n	  echo "No compiler warnings!";\n\n$(ALL_WARNS): %.o.$(WARNS_EXT) : %.o\n\n$(BUILD_DIR_LINK): $(BUILD_DIR)/.linked\n\n# Create a target ".linked" in this BUILD_DIR to tell Make that the "build" link\n# is currently correct, then delete the one in the OTHER_BUILD_DIR in case it\n# exists and $(DEBUG) is toggled later.\n$(BUILD_DIR)/.linked:\n	@ mkdir -p $(BUILD_DIR)\n	@ $(RM) $(OTHER_BUILD_DIR)/.linked\n	@ $(RM) -r $(BUILD_DIR_LINK)\n	@ ln -s $(BUILD_DIR) $(BUILD_DIR_LINK)\n	@ touch $@\n\n$(ALL_BUILD_DIRS): | $(BUILD_DIR_LINK)\n	@ mkdir -p $@\n\n$(DYNAMIC_NAME): $(OBJS) | $(LIB_BUILD_DIR)\n	@ echo LD -o $@\n	$(Q)$(CXX) -shared -o $@ $(OBJS) $(LINKFLAGS) $(LDFLAGS) $(DYNAMIC_FLAGS)\n\n$(STATIC_NAME): $(OBJS) | $(LIB_BUILD_DIR)\n	@ echo AR -o $@\n	$(Q)ar rcs $@ $(OBJS)\n\n$(BUILD_DIR)/%.o: %.cpp | $(ALL_BUILD_DIRS)\n	@ echo CXX $<\n	$(Q)$(CXX) $< $(CXXFLAGS) -c -o $@ 2> $@.$(WARNS_EXT) \\n		|| (cat $@.$(WARNS_EXT); exit 1)\n	@ cat $@.$(WARNS_EXT)\n\n$(PROTO_BUILD_DIR)/%.pb.o: $(PROTO_BUILD_DIR)/%.pb.cc $(PROTO_GEN_HEADER) \\n		| $(PROTO_BUILD_DIR)\n	@ echo CXX $<\n	$(Q)$(CXX) $< $(CXXFLAGS) -c -o $@ 2> $@.$(WARNS_EXT) \\n		|| (cat $@.$(WARNS_EXT); exit 1)\n	@ cat $@.$(WARNS_EXT)\n\n$(BUILD_DIR)/cuda/%.o: %.cu | $(ALL_BUILD_DIRS)\n	@ echo NVCC $<\n	$(Q)$(CUDA_DIR)/bin/nvcc $(NVCCFLAGS) $(CUDA_ARCH) -M $< -o ${@:.o=.d} \\n		-odir $(@D)\n	$(Q)$(CUDA_DIR)/bin/nvcc $(NVCCFLAGS) $(CUDA_ARCH) -c $< -o $@ 2> $@.$(WARNS_EXT) \\n		|| (cat $@.$(WARNS_EXT); exit 1)\n	@ cat $@.$(WARNS_EXT)\n\n$(TEST_ALL_BIN): $(TEST_MAIN_SRC) $(TEST_OBJS) $(GTEST_OBJ) \\n		| $(DYNAMIC_NAME) $(TEST_BIN_DIR)\n	@ echo CXX/LD -o $@ $<\n	$(Q)$(CXX) $(TEST_MAIN_SRC) $(TEST_OBJS) $(GTEST_OBJ) \\n		-o $@ $(LINKFLAGS) $(LDFLAGS) -l$(PROJECT) -Wl,-rpath,$(ORIGIN)/../lib\n\n$(TEST_CU_BINS): $(TEST_BIN_DIR)/%.testbin: $(TEST_CU_BUILD_DIR)/%.o \\n	$(GTEST_OBJ) | $(DYNAMIC_NAME) $(TEST_BIN_DIR)\n	@ echo LD $<\n	$(Q)$(CXX) $(TEST_MAIN_SRC) $< $(GTEST_OBJ) \\n		-o $@ $(LINKFLAGS) $(LDFLAGS) -l$(PROJECT) -Wl,-rpath,$(ORIGIN)/../lib\n\n$(TEST_CXX_BINS): $(TEST_BIN_DIR)/%.testbin: $(TEST_CXX_BUILD_DIR)/%.o \\n	$(GTEST_OBJ) | $(DYNAMIC_NAME) $(TEST_BIN_DIR)\n	@ echo LD $<\n	$(Q)$(CXX) $(TEST_MAIN_SRC) $< $(GTEST_OBJ) \\n		-o $@ $(LINKFLAGS) $(LDFLAGS) -l$(PROJECT) -Wl,-rpath,$(ORIGIN)/../lib\n\n# Target for extension-less symlinks to tool binaries with extension '*.bin'.\n$(TOOL_BUILD_DIR)/%: $(TOOL_BUILD_DIR)/%.bin | $(TOOL_BUILD_DIR)\n	@ $(RM) $@\n	@ ln -s $(abspath $<) $@\n\n$(TOOL_BINS): %.bin : %.o | $(DYNAMIC_NAME)\n	@ echo CXX/LD -o $@\n	$(Q)$(CXX) $< -o $@ $(LINKFLAGS) -l$(PROJECT) $(LDFLAGS) \\n		-Wl,-rpath,$(ORIGIN)/../lib\n\n$(EXAMPLE_BINS): %.bin : %.o | $(DYNAMIC_NAME)\n	@ echo CXX/LD -o $@\n	$(Q)$(CXX) $< -o $@ $(LINKFLAGS) -l$(PROJECT) $(LDFLAGS) \\n		-Wl,-rpath,$(ORIGIN)/../../lib\n		\nclkernels: src/caffe/greentea/cl_kernels/*.cl\n	src/caffe/greentea/cl_kernels.sh\n\nproto: $(PROTO_GEN_CC) $(PROTO_GEN_HEADER)\n\n$(PROTO_BUILD_DIR)/%.pb.cc $(PROTO_BUILD_DIR)/%.pb.h : \\n		$(PROTO_SRC_DIR)/%.proto | $(PROTO_BUILD_DIR)\n	@ echo PROTOC $<\n	$(Q)protoc --proto_path=$(PROTO_SRC_DIR) --cpp_out=$(PROTO_BUILD_DIR) $<\n\n$(PY_PROTO_BUILD_DIR)/%_pb2.py : $(PROTO_SRC_DIR)/%.proto \\n		$(PY_PROTO_INIT) | $(PY_PROTO_BUILD_DIR)\n	@ echo PROTOC \(python\) $<\n	$(Q)protoc --proto_path=$(PROTO_SRC_DIR) --python_out=$(PY_PROTO_BUILD_DIR) $<\n\n$(PY_PROTO_INIT): | $(PY_PROTO_BUILD_DIR)\n	touch $(PY_PROTO_INIT)\n\nclean:\n	@- $(RM) -rf $(ALL_BUILD_DIRS)\n	@- $(RM) -rf $(OTHER_BUILD_DIR)\n	@- $(RM) -rf $(BUILD_DIR_LINK)\n	@- $(RM) -rf $(DISTRIBUTE_DIR)\n	@- $(RM) $(PY$(PROJECT)_SO)\n	@- $(RM) $(MAT$(PROJECT)_SO)\n\nsupercleanfiles:\n	$(eval SUPERCLEAN_FILES := $(strip \\n			$(foreach ext,$(SUPERCLEAN_EXTS), $(shell find . -name '*$(ext)' \\n			-not -path './data/*'))))\n\nsupercleanlist: supercleanfiles\n	@ \\n	if [ -z "$(SUPERCLEAN_FILES)" ]; then \\n		echo "No generated files found."; \\n	else \\n		echo $(SUPERCLEAN_FILES) | tr ' ' '\n'; \\n	fi\n\nsuperclean: clean supercleanfiles\n	@ \\n	if [ -z "$(SUPERCLEAN_FILES)" ]; then \\n		echo "No generated files found."; \\n	else \\n		echo "Deleting the following generated files:"; \\n		echo $(SUPERCLEAN_FILES) | tr ' ' '\n'; \\n		$(RM) $(SUPERCLEAN_FILES); \\n	fi\n\n$(DIST_ALIASES): $(DISTRIBUTE_DIR)\n\n$(DISTRIBUTE_DIR): all py | $(DISTRIBUTE_SUBDIRS)\n	# add include\n	cp -r include $(DISTRIBUTE_DIR)/\n	mkdir -p $(DISTRIBUTE_DIR)/include/caffe/proto\n	cp $(PROTO_GEN_HEADER_SRCS) $(DISTRIBUTE_DIR)/include/caffe/proto\n	# add tool and example binaries\n	cp $(TOOL_BINS) $(DISTRIBUTE_DIR)/bin\n	cp $(EXAMPLE_BINS) $(DISTRIBUTE_DIR)/bin\n	# add libraries\n	cp $(STATIC_NAME) $(DISTRIBUTE_DIR)/lib\n	cp $(DYNAMIC_NAME) $(DISTRIBUTE_DIR)/lib\n	# add python - it's not the standard way, indeed...\n	cp -r python $(DISTRIBUTE_DIR)/python\n\n-include $(DEPS)
