<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Caffe: caffe::Layer&lt; Dtype &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Caffe
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecaffe.html">caffe</a></li><li class="navelem"><a class="el" href="classcaffe_1_1Layer.html">Layer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcaffe_1_1Layer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">caffe::Layer&lt; Dtype &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An interface for the units of computation which can be composed into a <a class="el" href="classcaffe_1_1Net.html" title="Connects Layers together into a directed acyclic graph (DAG) specified by a NetParameter. ">Net</a>.  
 <a href="classcaffe_1_1Layer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="layer_8hpp_source.html">layer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for caffe::Layer&lt; Dtype &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcaffe_1_1Layer.png" usemap="#caffe::Layer_3C_20Dtype_20_3E_map" alt=""/>
  <map id="caffe::Layer_3C_20Dtype_20_3E_map" name="caffe::Layer&lt; Dtype &gt;_map">
<area href="classcaffe_1_1AccuracyLayer.html" title="Computes the classification accuracy for a one-of-many classification task. " alt="caffe::AccuracyLayer&lt; Dtype &gt;" shape="rect" coords="242,56,474,80"/>
<area href="classcaffe_1_1ArgMaxLayer.html" title="Compute the index of the  max values for each datum across all dimensions . " alt="caffe::ArgMaxLayer&lt; Dtype &gt;" shape="rect" coords="242,112,474,136"/>
<area href="classcaffe_1_1BaseConvolutionLayer.html" title="Abstract base class that factors out the BLAS code common to ConvolutionLayer and DeconvolutionLayer..." alt="caffe::BaseConvolutionLayer&lt; Dtype &gt;" shape="rect" coords="242,168,474,192"/>
<area href="classcaffe_1_1BaseDataLayer.html" title="Provides base for data layers that feed blobs to the Net. " alt="caffe::BaseDataLayer&lt; Dtype &gt;" shape="rect" coords="242,224,474,248"/>
<area href="classcaffe_1_1BatchNormLayer.html" title="Normalizes the input to have 0-mean and/or unit (1) variance across the batch. " alt="caffe::BatchNormLayer&lt; Dtype &gt;" shape="rect" coords="242,280,474,304"/>
<area href="classcaffe_1_1BatchReindexLayer.html" title="Index into the input blob along its first axis. " alt="caffe::BatchReindexLayer&lt; Dtype &gt;" shape="rect" coords="242,336,474,360"/>
<area href="classcaffe_1_1BiasLayer.html" title="Computes a sum of two input Blobs, with the shape of the latter Blob &quot;broadcast&quot; to match the shape o..." alt="caffe::BiasLayer&lt; Dtype &gt;" shape="rect" coords="242,392,474,416"/>
<area href="classcaffe_1_1ConcatLayer.html" title="Takes at least two Blobs and concatenates them along either the num or channel dimension, outputting the result. " alt="caffe::ConcatLayer&lt; Dtype &gt;" shape="rect" coords="242,448,474,472"/>
<area href="classcaffe_1_1CropLayer.html" title="Takes a Blob and crop it, to the shape specified by the second input Blob, across all dimensions afte..." alt="caffe::CropLayer&lt; Dtype &gt;" shape="rect" coords="242,504,474,528"/>
<area href="classcaffe_1_1DummyDataLayer.html" title="Provides data to the Net generated by a Filler. " alt="caffe::DummyDataLayer&lt; Dtype &gt;" shape="rect" coords="242,560,474,584"/>
<area href="classcaffe_1_1EltwiseLayer.html" title="Compute elementwise operations, such as product and sum, along multiple input Blobs. " alt="caffe::EltwiseLayer&lt; Dtype &gt;" shape="rect" coords="242,616,474,640"/>
<area href="classcaffe_1_1EmbedLayer.html" title="A layer for learning &quot;embeddings&quot; of one-hot vector input. Equivalent to an InnerProductLayer with on..." alt="caffe::EmbedLayer&lt; Dtype &gt;" shape="rect" coords="242,672,474,696"/>
<area href="classcaffe_1_1FilterLayer.html" title="Takes two+ Blobs, interprets last Blob as a selector and filter remaining Blobs accordingly with sele..." alt="caffe::FilterLayer&lt; Dtype &gt;" shape="rect" coords="242,728,474,752"/>
<area href="classcaffe_1_1FlattenLayer.html" title="Reshapes the input Blob into flat vectors. " alt="caffe::FlattenLayer&lt; Dtype &gt;" shape="rect" coords="242,784,474,808"/>
<area href="classcaffe_1_1HDF5DataLayer.html" title="Provides data to the Net from HDF5 files. " alt="caffe::HDF5DataLayer&lt; Dtype &gt;" shape="rect" coords="242,840,474,864"/>
<area href="classcaffe_1_1HDF5OutputLayer.html" title="Write blobs to disk as HDF5 files. " alt="caffe::HDF5OutputLayer&lt; Dtype &gt;" shape="rect" coords="242,896,474,920"/>
<area href="classcaffe_1_1Im2colLayer.html" title="A helper for image operations that rearranges image regions into column vectors. Used by ConvolutionL..." alt="caffe::Im2colLayer&lt; Dtype &gt;" shape="rect" coords="242,952,474,976"/>
<area href="classcaffe_1_1InnerProductLayer.html" title="Also known as a &quot;fully-connected&quot; layer, computes an inner product with a set of learned weights..." alt="caffe::InnerProductLayer&lt; Dtype &gt;" shape="rect" coords="242,1008,474,1032"/>
<area href="classcaffe_1_1InputLayer.html" title="Provides data to the Net by assigning tops directly. " alt="caffe::InputLayer&lt; Dtype &gt;" shape="rect" coords="242,1064,474,1088"/>
<area href="classcaffe_1_1LossLayer.html" title="An interface for Layers that take two Blobs as input – usually (1) predictions and (2) ground-truth ..." alt="caffe::LossLayer&lt; Dtype &gt;" shape="rect" coords="242,1120,474,1144"/>
<area href="classcaffe_1_1LRNLayer.html" title="Normalize the input in a local region across or within feature maps. " alt="caffe::LRNLayer&lt; Dtype &gt;" shape="rect" coords="242,1176,474,1200"/>
<area href="classcaffe_1_1LSTMUnitLayer.html" title="A helper for LSTMLayer: computes a single timestep of the non-linearity of the LSTM, producing the updated cell and hidden states. " alt="caffe::LSTMUnitLayer&lt; Dtype &gt;" shape="rect" coords="242,1232,474,1256"/>
<area href="classcaffe_1_1MVNLayer.html" title="Normalizes the input to have 0-mean and/or unit (1) variance. " alt="caffe::MVNLayer&lt; Dtype &gt;" shape="rect" coords="242,1288,474,1312"/>
<area href="classcaffe_1_1NeuronLayer.html" title="An interface for layers that take one blob as input ( ) and produce one equally-sized blob as output ..." alt="caffe::NeuronLayer&lt; Dtype &gt;" shape="rect" coords="242,1344,474,1368"/>
<area href="classcaffe_1_1ParameterLayer.html" alt="caffe::ParameterLayer&lt; Dtype &gt;" shape="rect" coords="242,1400,474,1424"/>
<area href="classcaffe_1_1PoolingLayer.html" title="Pools the input image by taking the max, average, etc. within regions. " alt="caffe::PoolingLayer&lt; Dtype &gt;" shape="rect" coords="242,1456,474,1480"/>
<area href="classcaffe_1_1PythonLayer.html" alt="caffe::PythonLayer&lt; Dtype &gt;" shape="rect" coords="242,1512,474,1536"/>
<area href="classcaffe_1_1RecurrentLayer.html" title="An abstract class for implementing recurrent behavior inside of an unrolled network. This Layer type cannot be instantiated – instead, you should use one of its implementations which defines the recurrent architecture, such as RNNLayer or LSTMLayer. " alt="caffe::RecurrentLayer&lt; Dtype &gt;" shape="rect" coords="242,1568,474,1592"/>
<area href="classcaffe_1_1ReductionLayer.html" title="Compute &quot;reductions&quot; – operations that return a scalar output Blob for an input Blob of arbitrary si..." alt="caffe::ReductionLayer&lt; Dtype &gt;" shape="rect" coords="242,1624,474,1648"/>
<area href="classcaffe_1_1ReshapeLayer.html" alt="caffe::ReshapeLayer&lt; Dtype &gt;" shape="rect" coords="242,1680,474,1704"/>
<area href="classcaffe_1_1ScaleLayer.html" title="Computes the elementwise product of two input Blobs, with the shape of the latter Blob &quot;broadcast&quot; to..." alt="caffe::ScaleLayer&lt; Dtype &gt;" shape="rect" coords="242,1736,474,1760"/>
<area href="classcaffe_1_1SilenceLayer.html" title="Ignores bottom blobs while producing no top blobs. (This is useful to suppress outputs during testing..." alt="caffe::SilenceLayer&lt; Dtype &gt;" shape="rect" coords="242,1792,474,1816"/>
<area href="classcaffe_1_1SliceLayer.html" title="Takes a Blob and slices it along either the num or channel dimension, outputting multiple sliced Blob..." alt="caffe::SliceLayer&lt; Dtype &gt;" shape="rect" coords="242,1848,474,1872"/>
<area href="classcaffe_1_1SoftmaxLayer.html" title="Computes the softmax function. " alt="caffe::SoftmaxLayer&lt; Dtype &gt;" shape="rect" coords="242,1904,474,1928"/>
<area href="classcaffe_1_1SplitLayer.html" title="Creates a &quot;split&quot; path in the network by copying the bottom Blob into multiple top Blobs to be used b..." alt="caffe::SplitLayer&lt; Dtype &gt;" shape="rect" coords="242,1960,474,1984"/>
<area href="classcaffe_1_1SPPLayer.html" title="Does spatial pyramid pooling on the input image by taking the max, average, etc. within regions so th..." alt="caffe::SPPLayer&lt; Dtype &gt;" shape="rect" coords="242,2016,474,2040"/>
<area href="classcaffe_1_1TileLayer.html" title="Copy a Blob along specified dimensions. " alt="caffe::TileLayer&lt; Dtype &gt;" shape="rect" coords="242,2072,474,2096"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7b4e4ccea08c7b8b15acc6829d5735f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a7b4e4ccea08c7b8b15acc6829d5735f6">Layer</a> (const LayerParameter &amp;param)</td></tr>
<tr class="separator:a7b4e4ccea08c7b8b15acc6829d5735f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d6bfdb535ab8e96a971dec4ae39a84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a18d6bfdb535ab8e96a971dec4ae39a84">SetUp</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;bottom, const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;top)</td></tr>
<tr class="memdesc:a18d6bfdb535ab8e96a971dec4ae39a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements common layer setup functionality.  <a href="#a18d6bfdb535ab8e96a971dec4ae39a84">More...</a><br /></td></tr>
<tr class="separator:a18d6bfdb535ab8e96a971dec4ae39a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481323a3e0972c682787f2137468c29f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a481323a3e0972c682787f2137468c29f">LayerSetUp</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;bottom, const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;top)</td></tr>
<tr class="memdesc:a481323a3e0972c682787f2137468c29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does layer-specific setup: your layer should implement this function as well as Reshape.  <a href="#a481323a3e0972c682787f2137468c29f">More...</a><br /></td></tr>
<tr class="separator:a481323a3e0972c682787f2137468c29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c5d6a726e141ff520d36e21f07ffb4"><td class="memItemLeft" align="right" valign="top"><a id="a03c5d6a726e141ff520d36e21f07ffb4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a03c5d6a726e141ff520d36e21f07ffb4">ShareInParallel</a> () const</td></tr>
<tr class="memdesc:a03c5d6a726e141ff520d36e21f07ffb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a layer should be shared by multiple nets during data parallelism. By default, all layers except for data layers should not be shared. data layers should be shared to ensure each worker solver access data sequentially during data parallelism. <br /></td></tr>
<tr class="separator:a03c5d6a726e141ff520d36e21f07ffb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca48aa0ad6c40888baa659d8c2cfbc5"><td class="memItemLeft" align="right" valign="top"><a id="a3ca48aa0ad6c40888baa659d8c2cfbc5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a3ca48aa0ad6c40888baa659d8c2cfbc5">IsShared</a> () const</td></tr>
<tr class="memdesc:a3ca48aa0ad6c40888baa659d8c2cfbc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this layer is actually shared by other nets. If <a class="el" href="classcaffe_1_1Layer.html#a03c5d6a726e141ff520d36e21f07ffb4" title="Whether a layer should be shared by multiple nets during data parallelism. By default, all layers except for data layers should not be shared. data layers should be shared to ensure each worker solver access data sequentially during data parallelism. ">ShareInParallel()</a> is true and using more than one GPU and the net has TRAIN phase, then this function is expected return true. <br /></td></tr>
<tr class="separator:a3ca48aa0ad6c40888baa659d8c2cfbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4caf38c9f0f31c9c92af1bbefc04e4"><td class="memItemLeft" align="right" valign="top"><a id="a6d4caf38c9f0f31c9c92af1bbefc04e4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a6d4caf38c9f0f31c9c92af1bbefc04e4">SetShared</a> (bool is_shared)</td></tr>
<tr class="memdesc:a6d4caf38c9f0f31c9c92af1bbefc04e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether this layer is actually shared by other nets If <a class="el" href="classcaffe_1_1Layer.html#a03c5d6a726e141ff520d36e21f07ffb4" title="Whether a layer should be shared by multiple nets during data parallelism. By default, all layers except for data layers should not be shared. data layers should be shared to ensure each worker solver access data sequentially during data parallelism. ">ShareInParallel()</a> is true and using more than one GPU and the net has TRAIN phase, then is_shared should be set true. <br /></td></tr>
<tr class="separator:a6d4caf38c9f0f31c9c92af1bbefc04e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe981e8af8d93d587acf2a952be563d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a7fe981e8af8d93d587acf2a952be563d">Reshape</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;bottom, const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;top)=0</td></tr>
<tr class="memdesc:a7fe981e8af8d93d587acf2a952be563d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the shapes of top blobs and internal buffers to accommodate the shapes of the bottom blobs.  <a href="#a7fe981e8af8d93d587acf2a952be563d">More...</a><br /></td></tr>
<tr class="separator:a7fe981e8af8d93d587acf2a952be563d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57d272dabe8c709d2a785eebe72ca57"><td class="memItemLeft" align="right" valign="top">Dtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#ab57d272dabe8c709d2a785eebe72ca57">Forward</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;bottom, const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;top)</td></tr>
<tr class="memdesc:ab57d272dabe8c709d2a785eebe72ca57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the bottom blobs, compute the top blobs and the loss.  <a href="#ab57d272dabe8c709d2a785eebe72ca57">More...</a><br /></td></tr>
<tr class="separator:ab57d272dabe8c709d2a785eebe72ca57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183d343f5183a4762307f2c5e6ed1e12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a183d343f5183a4762307f2c5e6ed1e12">Backward</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;top, const vector&lt; bool &gt; &amp;propagate_down, const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;bottom)</td></tr>
<tr class="memdesc:a183d343f5183a4762307f2c5e6ed1e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the top blob error gradients, compute the bottom blob error gradients.  <a href="#a183d343f5183a4762307f2c5e6ed1e12">More...</a><br /></td></tr>
<tr class="separator:a183d343f5183a4762307f2c5e6ed1e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4524ce8641a30a8a4784aee1b2b4c8"><td class="memItemLeft" align="right" valign="top"><a id="aaf4524ce8641a30a8a4784aee1b2b4c8"></a>
vector&lt; shared_ptr&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#aaf4524ce8641a30a8a4784aee1b2b4c8">blobs</a> ()</td></tr>
<tr class="memdesc:aaf4524ce8641a30a8a4784aee1b2b4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector of learnable parameter blobs. <br /></td></tr>
<tr class="separator:aaf4524ce8641a30a8a4784aee1b2b4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff82274f146e2b6922d0ebac2aaf215"><td class="memItemLeft" align="right" valign="top"><a id="adff82274f146e2b6922d0ebac2aaf215"></a>
const LayerParameter &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#adff82274f146e2b6922d0ebac2aaf215">layer_param</a> () const</td></tr>
<tr class="memdesc:adff82274f146e2b6922d0ebac2aaf215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the layer parameter. <br /></td></tr>
<tr class="separator:adff82274f146e2b6922d0ebac2aaf215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1754828dda22cc8daa2f63377f3579"><td class="memItemLeft" align="right" valign="top"><a id="a4a1754828dda22cc8daa2f63377f3579"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a4a1754828dda22cc8daa2f63377f3579">ToProto</a> (LayerParameter *param, bool write_diff=false)</td></tr>
<tr class="memdesc:a4a1754828dda22cc8daa2f63377f3579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the layer parameter to a protocol buffer. <br /></td></tr>
<tr class="separator:a4a1754828dda22cc8daa2f63377f3579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899410336f30821644c8bd6c69a070c9"><td class="memItemLeft" align="right" valign="top"><a id="a899410336f30821644c8bd6c69a070c9"></a>
Dtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a899410336f30821644c8bd6c69a070c9">loss</a> (const int top_index) const</td></tr>
<tr class="memdesc:a899410336f30821644c8bd6c69a070c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scalar loss associated with a top blob at a given index. <br /></td></tr>
<tr class="separator:a899410336f30821644c8bd6c69a070c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899b09f4b91ada8545b3a43ee91e0d69"><td class="memItemLeft" align="right" valign="top"><a id="a899b09f4b91ada8545b3a43ee91e0d69"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a899b09f4b91ada8545b3a43ee91e0d69">set_loss</a> (const int top_index, const Dtype value)</td></tr>
<tr class="memdesc:a899b09f4b91ada8545b3a43ee91e0d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the loss associated with a top blob at a given index. <br /></td></tr>
<tr class="separator:a899b09f4b91ada8545b3a43ee91e0d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8952bff6bc4c2a96d8ea30d8ff65b198"><td class="memItemLeft" align="right" valign="top"><a id="a8952bff6bc4c2a96d8ea30d8ff65b198"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a8952bff6bc4c2a96d8ea30d8ff65b198">type</a> () const</td></tr>
<tr class="memdesc:a8952bff6bc4c2a96d8ea30d8ff65b198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the layer type. <br /></td></tr>
<tr class="separator:a8952bff6bc4c2a96d8ea30d8ff65b198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5ee0494d85f5f55fc4396537cbc60f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a8e5ee0494d85f5f55fc4396537cbc60f">ExactNumBottomBlobs</a> () const</td></tr>
<tr class="memdesc:a8e5ee0494d85f5f55fc4396537cbc60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact number of bottom blobs required by the layer, or -1 if no exact number is required.  <a href="#a8e5ee0494d85f5f55fc4396537cbc60f">More...</a><br /></td></tr>
<tr class="separator:a8e5ee0494d85f5f55fc4396537cbc60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3cb2bafaefda5d4760aaebd0b72def"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#aca3cb2bafaefda5d4760aaebd0b72def">MinBottomBlobs</a> () const</td></tr>
<tr class="memdesc:aca3cb2bafaefda5d4760aaebd0b72def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum number of bottom blobs required by the layer, or -1 if no minimum number is required.  <a href="#aca3cb2bafaefda5d4760aaebd0b72def">More...</a><br /></td></tr>
<tr class="separator:aca3cb2bafaefda5d4760aaebd0b72def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bdc989053e0363ab032026b46de7c3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#af8bdc989053e0363ab032026b46de7c3">MaxBottomBlobs</a> () const</td></tr>
<tr class="memdesc:af8bdc989053e0363ab032026b46de7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of bottom blobs required by the layer, or -1 if no maximum number is required.  <a href="#af8bdc989053e0363ab032026b46de7c3">More...</a><br /></td></tr>
<tr class="separator:af8bdc989053e0363ab032026b46de7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e2ca72c719e4b2f1f9216ccfb0d37f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a64e2ca72c719e4b2f1f9216ccfb0d37f">ExactNumTopBlobs</a> () const</td></tr>
<tr class="memdesc:a64e2ca72c719e4b2f1f9216ccfb0d37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact number of top blobs required by the layer, or -1 if no exact number is required.  <a href="#a64e2ca72c719e4b2f1f9216ccfb0d37f">More...</a><br /></td></tr>
<tr class="separator:a64e2ca72c719e4b2f1f9216ccfb0d37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e4c8d642e413948b131d851a8462a4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#ab9e4c8d642e413948b131d851a8462a4">MinTopBlobs</a> () const</td></tr>
<tr class="memdesc:ab9e4c8d642e413948b131d851a8462a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum number of top blobs required by the layer, or -1 if no minimum number is required.  <a href="#ab9e4c8d642e413948b131d851a8462a4">More...</a><br /></td></tr>
<tr class="separator:ab9e4c8d642e413948b131d851a8462a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c03df0b6e40e776c94001e19994a2e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#ac6c03df0b6e40e776c94001e19994a2e">MaxTopBlobs</a> () const</td></tr>
<tr class="memdesc:ac6c03df0b6e40e776c94001e19994a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of top blobs required by the layer, or -1 if no maximum number is required.  <a href="#ac6c03df0b6e40e776c94001e19994a2e">More...</a><br /></td></tr>
<tr class="separator:ac6c03df0b6e40e776c94001e19994a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af452a938bc7596f9b5e9900c8dc4ab3d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#af452a938bc7596f9b5e9900c8dc4ab3d">EqualNumBottomTopBlobs</a> () const</td></tr>
<tr class="memdesc:af452a938bc7596f9b5e9900c8dc4ab3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the layer requires an equal number of bottom and top blobs.  <a href="#af452a938bc7596f9b5e9900c8dc4ab3d">More...</a><br /></td></tr>
<tr class="separator:af452a938bc7596f9b5e9900c8dc4ab3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50130669e230a168d1f8fbbb8171f054"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a50130669e230a168d1f8fbbb8171f054">AutoTopBlobs</a> () const</td></tr>
<tr class="memdesc:a50130669e230a168d1f8fbbb8171f054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether "anonymous" top blobs are created automatically by the layer.  <a href="#a50130669e230a168d1f8fbbb8171f054">More...</a><br /></td></tr>
<tr class="separator:a50130669e230a168d1f8fbbb8171f054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0b2bffcd6d57e4bd49f820941badb6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a1c0b2bffcd6d57e4bd49f820941badb6">AllowForceBackward</a> (const int bottom_index) const</td></tr>
<tr class="memdesc:a1c0b2bffcd6d57e4bd49f820941badb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether to allow force_backward for a given bottom blob index.  <a href="#a1c0b2bffcd6d57e4bd49f820941badb6">More...</a><br /></td></tr>
<tr class="separator:a1c0b2bffcd6d57e4bd49f820941badb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3708013b0231e71d725252e10ce6e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a1a3708013b0231e71d725252e10ce6e3">param_propagate_down</a> (const int param_id)</td></tr>
<tr class="memdesc:a1a3708013b0231e71d725252e10ce6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the layer should compute gradients w.r.t. a parameter at a particular index given by param_id.  <a href="#a1a3708013b0231e71d725252e10ce6e3">More...</a><br /></td></tr>
<tr class="separator:a1a3708013b0231e71d725252e10ce6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6fcb843803ed556f0a69cc2864379b"><td class="memItemLeft" align="right" valign="top"><a id="a9a6fcb843803ed556f0a69cc2864379b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a9a6fcb843803ed556f0a69cc2864379b">set_param_propagate_down</a> (const int param_id, const bool value)</td></tr>
<tr class="memdesc:a9a6fcb843803ed556f0a69cc2864379b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the layer should compute gradients w.r.t. a parameter at a particular index given by param_id. <br /></td></tr>
<tr class="separator:a9a6fcb843803ed556f0a69cc2864379b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a576ac6a60b1e99fe383831f52a6cea77"><td class="memItemLeft" align="right" valign="top"><a id="a576ac6a60b1e99fe383831f52a6cea77"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a576ac6a60b1e99fe383831f52a6cea77">Forward_cpu</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;bottom, const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;top)=0</td></tr>
<tr class="memdesc:a576ac6a60b1e99fe383831f52a6cea77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the CPU device, compute the layer output. <br /></td></tr>
<tr class="separator:a576ac6a60b1e99fe383831f52a6cea77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a88d8fb290877b4c7eb37daa3499de"><td class="memItemLeft" align="right" valign="top"><a id="af3a88d8fb290877b4c7eb37daa3499de"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#af3a88d8fb290877b4c7eb37daa3499de">Forward_gpu</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;bottom, const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;top)</td></tr>
<tr class="memdesc:af3a88d8fb290877b4c7eb37daa3499de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the GPU device, compute the layer output. Fall back to <a class="el" href="classcaffe_1_1Layer.html#a576ac6a60b1e99fe383831f52a6cea77" title="Using the CPU device, compute the layer output. ">Forward_cpu()</a> if unavailable. <br /></td></tr>
<tr class="separator:af3a88d8fb290877b4c7eb37daa3499de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c9b2a321dc713e0eaef530d02dc37f"><td class="memItemLeft" align="right" valign="top"><a id="a75c9b2a321dc713e0eaef530d02dc37f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a75c9b2a321dc713e0eaef530d02dc37f">Backward_cpu</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;top, const vector&lt; bool &gt; &amp;propagate_down, const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;bottom)=0</td></tr>
<tr class="memdesc:a75c9b2a321dc713e0eaef530d02dc37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the CPU device, compute the gradients for any parameters and for the bottom blobs if propagate_down is true. <br /></td></tr>
<tr class="separator:a75c9b2a321dc713e0eaef530d02dc37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faee52af6250a38d1b879008257f5a7"><td class="memItemLeft" align="right" valign="top"><a id="a6faee52af6250a38d1b879008257f5a7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a6faee52af6250a38d1b879008257f5a7">Backward_gpu</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;top, const vector&lt; bool &gt; &amp;propagate_down, const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;bottom)</td></tr>
<tr class="memdesc:a6faee52af6250a38d1b879008257f5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the GPU device, compute the gradients for any parameters and for the bottom blobs if propagate_down is true. Fall back to <a class="el" href="classcaffe_1_1Layer.html#a75c9b2a321dc713e0eaef530d02dc37f" title="Using the CPU device, compute the gradients for any parameters and for the bottom blobs if propagate_...">Backward_cpu()</a> if unavailable. <br /></td></tr>
<tr class="separator:a6faee52af6250a38d1b879008257f5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c8036130225fbc874a986bdf4b27e2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a55c8036130225fbc874a986bdf4b27e2">CheckBlobCounts</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;bottom, const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;top)</td></tr>
<tr class="separator:a55c8036130225fbc874a986bdf4b27e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04eb2a3d1d59c64cd64c233217d5d6fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a04eb2a3d1d59c64cd64c233217d5d6fc">SetLossWeights</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;top)</td></tr>
<tr class="separator:a04eb2a3d1d59c64cd64c233217d5d6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7ed12bb2df25c887e41d7ea9557fc701"><td class="memItemLeft" align="right" valign="top">LayerParameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a7ed12bb2df25c887e41d7ea9557fc701">layer_param_</a></td></tr>
<tr class="separator:a7ed12bb2df25c887e41d7ea9557fc701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d04ad7f595a82a1c811f102d68b8a19"><td class="memItemLeft" align="right" valign="top">Phase&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a1d04ad7f595a82a1c811f102d68b8a19">phase_</a></td></tr>
<tr class="separator:a1d04ad7f595a82a1c811f102d68b8a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8073fcf2c139b47eb99ce71b346b1321"><td class="memItemLeft" align="right" valign="top">vector&lt; shared_ptr&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a8073fcf2c139b47eb99ce71b346b1321">blobs_</a></td></tr>
<tr class="separator:a8073fcf2c139b47eb99ce71b346b1321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4a05def9ff3b42ad72404210613ef7"><td class="memItemLeft" align="right" valign="top">vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#acd4a05def9ff3b42ad72404210613ef7">param_propagate_down_</a></td></tr>
<tr class="separator:acd4a05def9ff3b42ad72404210613ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d347229a139500994e7a926c680486"><td class="memItemLeft" align="right" valign="top">vector&lt; Dtype &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#af6d347229a139500994e7a926c680486">loss_</a></td></tr>
<tr class="separator:af6d347229a139500994e7a926c680486"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Dtype&gt;<br />
class caffe::Layer&lt; Dtype &gt;</h3>

<p>An interface for the units of computation which can be composed into a <a class="el" href="classcaffe_1_1Net.html" title="Connects Layers together into a directed acyclic graph (DAG) specified by a NetParameter. ">Net</a>. </p>
<p><a class="el" href="classcaffe_1_1Layer.html" title="An interface for the units of computation which can be composed into a Net. ">Layer</a>s must implement a Forward function, in which they take their input (bottom) <a class="el" href="classcaffe_1_1Blob.html" title="A wrapper around SyncedMemory holders serving as the basic computational unit through which Layers...">Blob</a>s (if any) and compute their output <a class="el" href="classcaffe_1_1Blob.html" title="A wrapper around SyncedMemory holders serving as the basic computational unit through which Layers...">Blob</a>s (if any). They may also implement a Backward function, in which they compute the error gradients with respect to their input <a class="el" href="classcaffe_1_1Blob.html" title="A wrapper around SyncedMemory holders serving as the basic computational unit through which Layers...">Blob</a>s, given the error gradients with their output <a class="el" href="classcaffe_1_1Blob.html" title="A wrapper around SyncedMemory holders serving as the basic computational unit through which Layers...">Blob</a>s. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7b4e4ccea08c7b8b15acc6829d5735f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4e4ccea08c7b8b15acc6829d5735f6">&sect;&nbsp;</a></span>Layer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::<a class="el" href="classcaffe_1_1Layer.html">Layer</a> </td>
          <td>(</td>
          <td class="paramtype">const LayerParameter &amp;&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You should not implement your own constructor. Any set up code should go to <a class="el" href="classcaffe_1_1Layer.html#a18d6bfdb535ab8e96a971dec4ae39a84" title="Implements common layer setup functionality. ">SetUp()</a>, where the dimensions of the bottom blobs are provided to the layer. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1c0b2bffcd6d57e4bd49f820941badb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0b2bffcd6d57e4bd49f820941badb6">&sect;&nbsp;</a></span>AllowForceBackward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::AllowForceBackward </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>bottom_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether to allow force_backward for a given bottom blob index. </p>
<p>If AllowForceBackward(i) == false, we will ignore the force_backward setting and backpropagate to blob i only if it needs gradient information (as is done when force_backward == false). </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1LSTMUnitLayer.html#a9c46167bc8b96b28196bc24a5515b531">caffe::LSTMUnitLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1RecurrentLayer.html#a8d91610cc8b9615a1db4f07fe5590a37">caffe::RecurrentLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1EuclideanLossLayer.html#a76dd3fde9f09cb9840f05ee035b5a2c5">caffe::EuclideanLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ContrastiveLossLayer.html#af0f16d5119ac6118b670c1966c38fd7d">caffe::ContrastiveLossLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1LossLayer.html#a36d35155bfe0de53a79c517f33759612">caffe::LossLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a id="a50130669e230a168d1f8fbbb8171f054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50130669e230a168d1f8fbbb8171f054">&sect;&nbsp;</a></span>AutoTopBlobs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::AutoTopBlobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether "anonymous" top blobs are created automatically by the layer. </p>
<p>If this method returns true, <a class="el" href="classcaffe_1_1Net.html#ae9fcfaabc89165d6c0cb4b14b4c6b584" title="Initialize a network with a NetParameter. ">Net::Init</a> will create enough "anonymous" top blobs to fulfill the requirement specified by <a class="el" href="classcaffe_1_1Layer.html#a64e2ca72c719e4b2f1f9216ccfb0d37f" title="Returns the exact number of top blobs required by the layer, or -1 if no exact number is required...">ExactNumTopBlobs()</a> or <a class="el" href="classcaffe_1_1Layer.html#ab9e4c8d642e413948b131d851a8462a4" title="Returns the minimum number of top blobs required by the layer, or -1 if no minimum number is required...">MinTopBlobs()</a>. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1LossLayer.html#ae98a9942cdb1c67e09d45cc2d876618e">caffe::LossLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a id="a183d343f5183a4762307f2c5e6ed1e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183d343f5183a4762307f2c5e6ed1e12">&sect;&nbsp;</a></span>Backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::Backward </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>propagate_down</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the top blob error gradients, compute the bottom blob error gradients. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top</td><td>the output blobs, whose diff fields store the gradient of the error with respect to themselves </td></tr>
    <tr><td class="paramname">propagate_down</td><td>a vector with equal length to bottom, with each index indicating whether to propagate the error gradients down to the bottom blob at the corresponding index </td></tr>
    <tr><td class="paramname">bottom</td><td>the input blobs, whose diff fields will store the gradient of the error with respect to themselves after Backward is run</td></tr>
  </table>
  </dd>
</dl>
<p>The Backward wrapper calls the relevant device wrapper function (Backward_cpu or Backward_gpu) to compute the bottom blob diffs given the top blob diffs.</p>
<p>Your layer should implement Backward_cpu and (optionally) Backward_gpu. </p>

</div>
</div>
<a id="a55c8036130225fbc874a986bdf4b27e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c8036130225fbc874a986bdf4b27e2">&sect;&nbsp;</a></span>CheckBlobCounts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::CheckBlobCounts </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called by the parent <a class="el" href="classcaffe_1_1Layer.html" title="An interface for the units of computation which can be composed into a Net. ">Layer</a>'s SetUp to check that the number of bottom and top Blobs provided as input match the expected numbers specified by the {ExactNum,Min,Max}{Bottom,Top}Blobs() functions. </p>

</div>
</div>
<a id="af452a938bc7596f9b5e9900c8dc4ab3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af452a938bc7596f9b5e9900c8dc4ab3d">&sect;&nbsp;</a></span>EqualNumBottomTopBlobs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::EqualNumBottomTopBlobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the layer requires an equal number of bottom and top blobs. </p>
<p>This method should be overridden to return true if your layer expects an equal number of bottom and top blobs. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1BaseConvolutionLayer.html#ad8e839460bf52abe3df2008b99a1810d">caffe::BaseConvolutionLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a id="a8e5ee0494d85f5f55fc4396537cbc60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5ee0494d85f5f55fc4396537cbc60f">&sect;&nbsp;</a></span>ExactNumBottomBlobs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::ExactNumBottomBlobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the exact number of bottom blobs required by the layer, or -1 if no exact number is required. </p>
<p>This method should be overridden to return a non-negative value if your layer expects some exact number of bottom blobs. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1LSTMUnitLayer.html#a087f5f5b0e6c50d98e7a7d04aa35f1b9">caffe::LSTMUnitLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InfogainLossLayer.html#aa03732f381764180748479c83b289869">caffe::InfogainLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BatchNormLayer.html#a5b87980f25eea544ebff916586c870e6">caffe::BatchNormLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ArgMaxLayer.html#a786fb4163cd0a31a564100ce7e4b74b2">caffe::ArgMaxLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ContrastiveLossLayer.html#aa6f3ad6918e64ffa1828e821accf25e9">caffe::ContrastiveLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1HDF5OutputLayer.html#a92fb5561414d7e8b8845b0279b1ee847">caffe::HDF5OutputLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1AccuracyLayer.html#afb0d3db8e4a18bec0e05d54d11453ef1">caffe::AccuracyLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1HDF5DataLayer.html#a4eb72974cea32c84acb6b8012a0d326b">caffe::HDF5DataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1AbsValLayer.html#acac806dbc6d3fa3dd7daae00caabd731">caffe::AbsValLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LRNLayer.html#a32be44f9f361d29f05261bd174d92321">caffe::LRNLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1WindowDataLayer.html#ac982c8170a7f899366321412a7bb91d7">caffe::WindowDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1DummyDataLayer.html#a73101a8ace6de2b179e36c13be17cb17">caffe::DummyDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ImageDataLayer.html#a6776c86faf14e35ae7be9848c7012aa5">caffe::ImageDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InputLayer.html#ac4c1f2f0444a103727d793a6ae410e67">caffe::InputLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LossLayer.html#af1620064baefb711e2c767bdc92b6fb1">caffe::LossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1CropLayer.html#ac6386917437ef54003bb7f8c2618f5fe">caffe::CropLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1FlattenLayer.html#a0b0f583d8952d7cd45cbf4bae2a38548">caffe::FlattenLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1EmbedLayer.html#a0634500a12e1d2299b7c8556976e4529">caffe::EmbedLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1Im2colLayer.html#a35772d667af49afe707c7b1db881c573">caffe::Im2colLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ReductionLayer.html#a64694af2e56723590072cac88bf825c7">caffe::ReductionLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BatchReindexLayer.html#a4120d2fd610655c7ad3d846637564bc6">caffe::BatchReindexLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InnerProductLayer.html#a5afdeb6b448b2f7d0637afa554381500">caffe::InnerProductLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ParameterLayer.html#a0acd33d14dd208c5a439940c50c6d3d3">caffe::ParameterLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ReshapeLayer.html#ad97ea6043b01351e85b39b512ae0e489">caffe::ReshapeLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SliceLayer.html#abfc6e86b0b22c156ddc350168cd7757b">caffe::SliceLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SPPLayer.html#a0fcc7996823cba1a468e82b3f9058ff0">caffe::SPPLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1MemoryDataLayer.html#a05a867526de7e0c6ec4851a97f52a47b">caffe::MemoryDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1PoolingLayer.html#a07dc8b1c3bfa3a997dd86b4e53f54019">caffe::PoolingLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1DataLayer.html#a2b6fa99ededf0863d8bab4a7a46addae">caffe::DataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SplitLayer.html#a8ff310ac37e1e79ce6ef8fbc95be0cd9">caffe::SplitLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1MVNLayer.html#afd9b078a1bb48de9b91f3766edbbf058">caffe::MVNLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1NeuronLayer.html#abb6c0e6acd2863baf47d6e6acda6f55f">caffe::NeuronLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SoftmaxLayer.html#afe44488dde78e6bcf6d4bdad97ee4986">caffe::SoftmaxLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1TileLayer.html#ac7e0da0e543f134e04b00d8625132b71">caffe::TileLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a id="a64e2ca72c719e4b2f1f9216ccfb0d37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e2ca72c719e4b2f1f9216ccfb0d37f">&sect;&nbsp;</a></span>ExactNumTopBlobs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::ExactNumTopBlobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the exact number of top blobs required by the layer, or -1 if no exact number is required. </p>
<p>This method should be overridden to return a non-negative value if your layer expects some exact number of top blobs. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1LSTMUnitLayer.html#a5f56fd304b6581697cbf309ebb8bc9b7">caffe::LSTMUnitLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SoftmaxWithLossLayer.html#a9035d000b2ce51a973f255a5eb2df8e3">caffe::SoftmaxWithLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BatchNormLayer.html#ab8575decdd0c5c42e24b9c3424f708ad">caffe::BatchNormLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ArgMaxLayer.html#a45e9c6e7b572b915be8731fcb6403695">caffe::ArgMaxLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1RecurrentLayer.html#a4cb9032f0942c0fef5f6c7094c7b2ab8">caffe::RecurrentLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LossLayer.html#aa5d5ab714a14082f5343dc9c49025b23">caffe::LossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1HDF5OutputLayer.html#ad11b8da0a6217a0f9a63789b360b1c99">caffe::HDF5OutputLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ScaleLayer.html#aeffb8fcfc522f7365c23b0e6ae5c232e">caffe::ScaleLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1AbsValLayer.html#aaf18bf4b77994475e8b55e5cefaa654a">caffe::AbsValLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BiasLayer.html#a9552dc137a5bcbdd17bdb3321d678595">caffe::BiasLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LRNLayer.html#ac0ee88b119c38749c50e914521cdc148">caffe::LRNLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1WindowDataLayer.html#a7bd9264758f462b3392d2eedec8b1c99">caffe::WindowDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ImageDataLayer.html#aa9182d46877b8514fca86e3588249567">caffe::ImageDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1CropLayer.html#a7e4a9aa634577308bc189adcf0ac22ed">caffe::CropLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1FlattenLayer.html#a09d5ccd980598cce0472b3bd66316c08">caffe::FlattenLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1EmbedLayer.html#af02f4561fa25a979e523aae851bed39d">caffe::EmbedLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1Im2colLayer.html#ab2cf1f7dd41b801ed32471ec492d423c">caffe::Im2colLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ReductionLayer.html#a14224774af732030c5f1c8a3d79e1fc3">caffe::ReductionLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BatchReindexLayer.html#a7d5c537334359c2a83cce489fb534342">caffe::BatchReindexLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1EltwiseLayer.html#a60ae4a38cade1cc7f6111e51cabb441b">caffe::EltwiseLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InnerProductLayer.html#a652d8a5b07b72938a81f50305c1a8ee1">caffe::InnerProductLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ParameterLayer.html#aeb70ea5cec478f098259356690b01c9b">caffe::ParameterLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ReshapeLayer.html#a3318c2404c6072ba07178b48d39ef0f5">caffe::ReshapeLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SPPLayer.html#a345f640e6c1d3e9ee929d706b68300e9">caffe::SPPLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1MemoryDataLayer.html#af714b4cbc022be1592ad26c300b63ae4">caffe::MemoryDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ConcatLayer.html#a0f19a4cac8676927f9c83010957a2921">caffe::ConcatLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1MVNLayer.html#ae10d9ef135adf3cd25e86ce06188c814">caffe::MVNLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1NeuronLayer.html#a47ac5e7208e4b14ad1e4040a621dbfbc">caffe::NeuronLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SoftmaxLayer.html#a6bc4748c20e0940e5367ed4d50f4a11b">caffe::SoftmaxLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SilenceLayer.html#a1e072cbda98dbc57001ce92432b045b8">caffe::SilenceLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1TileLayer.html#a1040cc3b4fb028d54f67a685513d745b">caffe::TileLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a id="ab57d272dabe8c709d2a785eebe72ca57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57d272dabe8c709d2a785eebe72ca57">&sect;&nbsp;</a></span>Forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Dtype <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::Forward </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the bottom blobs, compute the top blobs and the loss. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bottom</td><td>the input blobs, whose data fields store the input data for this layer </td></tr>
    <tr><td class="paramname">top</td><td>the preshaped output blobs, whose data fields will store this layers' outputs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total loss from the layer.</dd></dl>
<p>The Forward wrapper calls the relevant device wrapper function (Forward_cpu or Forward_gpu) to compute the top blob values given the bottom blobs. If the layer has any non-zero loss_weights, the wrapper then computes and returns the loss.</p>
<p>Your layer should implement Forward_cpu and (optionally) Forward_gpu. </p>

</div>
</div>
<a id="a481323a3e0972c682787f2137468c29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481323a3e0972c682787f2137468c29f">&sect;&nbsp;</a></span>LayerSetUp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::LayerSetUp </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does layer-specific setup: your layer should implement this function as well as Reshape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bottom</td><td>the preshaped input blobs, whose data fields store the input data for this layer </td></tr>
    <tr><td class="paramname">top</td><td>the allocated but unshaped output blobs</td></tr>
  </table>
  </dd>
</dl>
<p>This method should do one-time layer specific setup. This includes reading and processing relevent parameters from the <code>layer_param_</code>. Setting up the shapes of top blobs and internal buffers should be done in <code>Reshape</code>, which will be called before the forward pass to adjust the top blob sizes. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1BasePrefetchingDataLayer.html#ad3b7914abaa6d46c148864c0e28204ad">caffe::BasePrefetchingDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SoftmaxWithLossLayer.html#a96cd04896d4b805fcaf36c2c6522ae10">caffe::SoftmaxWithLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InfogainLossLayer.html#a772be3f4074c72b3cf9214bda3422402">caffe::InfogainLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SigmoidCrossEntropyLossLayer.html#aa1535140dd4eb94557c3afc89076d56d">caffe::SigmoidCrossEntropyLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BatchNormLayer.html#a259d8b26c05450339b33ad024f356b6a">caffe::BatchNormLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ContrastiveLossLayer.html#a943e67e7bb9c2362ec20ce44c777beac">caffe::ContrastiveLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ArgMaxLayer.html#a53069bd5efc4639de93a8111da772572">caffe::ArgMaxLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1DropoutLayer.html#addcfd0822c1c5e3591bc7001a034b167">caffe::DropoutLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1PReLULayer.html#a85e7207b664a4db8eb718f2075f44920">caffe::PReLULayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ExpLayer.html#a45ec267bdfd48e8aa34490e146405b9e">caffe::ExpLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LogLayer.html#a87e062000908b474ac4cda3b2f3c6f1e">caffe::LogLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1AccuracyLayer.html#a1f2447583c670d92ff6e2c8d53fb4dd9">caffe::AccuracyLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1PowerLayer.html#a954ad3da9a5fd54665de1181b6165796">caffe::PowerLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1RecurrentLayer.html#a4eec13bfbe23b1e3eb2bbc4652bd6952">caffe::RecurrentLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ScaleLayer.html#a9781f923f1ff0aad8549e0e93eebb941">caffe::ScaleLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1AbsValLayer.html#a4ef25e7d0cbe06404948d7e763bf0f84">caffe::AbsValLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1HDF5OutputLayer.html#aed2dea5250c86c46dd866fbb241dd9f6">caffe::HDF5OutputLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ThresholdLayer.html#a14e3782a6bea7bba511f3d6f23344037">caffe::ThresholdLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1HDF5DataLayer.html#afcd473ff34b4035122ba9119fc67498c">caffe::HDF5DataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BaseDataLayer.html#a7028919adf87326b808a2c7b21e8e927">caffe::BaseDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LossLayer.html#aa6fc7c2e90be66f1c1f0683637c949da">caffe::LossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LRNLayer.html#ac7ae4b839d952b785b9911c258bd5b48">caffe::LRNLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BiasLayer.html#aa62a9554bf4fc3eb4db124da0d89fd85">caffe::BiasLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1CropLayer.html#a59dcb04b78d55f666b69ff001c90caa7">caffe::CropLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1EmbedLayer.html#aaace16d2beba7db887c7b59213268bc2">caffe::EmbedLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1Im2colLayer.html#ac4d6f34378681fa197546468b5aa6fd6">caffe::Im2colLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ReductionLayer.html#aafe0aa825e019ea35225a8e493e4e919">caffe::ReductionLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1DummyDataLayer.html#a43b495bfead8d18bf1d8eaf7bf91e3e4">caffe::DummyDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1EltwiseLayer.html#a02516b6e7b1b0d032e586785687bcabc">caffe::EltwiseLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1FilterLayer.html#a26a302fd9629af812e7d0714db79bb53">caffe::FilterLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InnerProductLayer.html#a4adc29913343ddec1813f3a899e449cc">caffe::InnerProductLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InputLayer.html#a58be7dd9b52c1a98a872300e5108e065">caffe::InputLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ReshapeLayer.html#a99db2601ec64ff20880641b6f6429947">caffe::ReshapeLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SliceLayer.html#a92c1cdabdce4c92b9a4ee58e2ceb601e">caffe::SliceLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SPPLayer.html#a7241f9c4dfba841bc76a93298a3d28ee">caffe::SPPLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BaseConvolutionLayer.html#a422e1ef9e6c8b4574f7677bb125e234a">caffe::BaseConvolutionLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1PoolingLayer.html#aa310fbe7d766ac96a1957aca6a3c4469">caffe::PoolingLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ConcatLayer.html#af4fc13f4977f84a30af260096ffd55d2">caffe::ConcatLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1PythonLayer.html#ae5baf7b7552ff0113c174b0e77db5f4c">caffe::PythonLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1ParameterLayer.html#a1485ccdbd01513b89b29a79df7cda6ee">caffe::ParameterLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a id="af8bdc989053e0363ab032026b46de7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bdc989053e0363ab032026b46de7c3">&sect;&nbsp;</a></span>MaxBottomBlobs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::MaxBottomBlobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of bottom blobs required by the layer, or -1 if no maximum number is required. </p>
<p>This method should be overridden to return a non-negative value if your layer expects some maximum number of bottom blobs. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1InfogainLossLayer.html#a9b2372959a16da1e80ae7a98b7689a4c">caffe::InfogainLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1RecurrentLayer.html#a983e1ead91884f9d2049a3000254961c">caffe::RecurrentLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ScaleLayer.html#a7867d035776f78fe486ce633ec0520ad">caffe::ScaleLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1BiasLayer.html#abdb89e3bc940f999d1d4da83de90a97c">caffe::BiasLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a id="ac6c03df0b6e40e776c94001e19994a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c03df0b6e40e776c94001e19994a2e">&sect;&nbsp;</a></span>MaxTopBlobs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::MaxTopBlobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of top blobs required by the layer, or -1 if no maximum number is required. </p>
<p>This method should be overridden to return a non-negative value if your layer expects some maximum number of top blobs. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1SoftmaxWithLossLayer.html#a5a0b4c02fe76ae9087cd8b1b9edd9910">caffe::SoftmaxWithLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1AccuracyLayer.html#a7591ae6d50dd7d96b91241b5b0368997">caffe::AccuracyLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1PoolingLayer.html#a76539d04ef7252c12e932ea703f8246b">caffe::PoolingLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1DataLayer.html#ac47e9f3bff3db9d7364f6c392427745c">caffe::DataLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a id="aca3cb2bafaefda5d4760aaebd0b72def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3cb2bafaefda5d4760aaebd0b72def">&sect;&nbsp;</a></span>MinBottomBlobs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::MinBottomBlobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum number of bottom blobs required by the layer, or -1 if no minimum number is required. </p>
<p>This method should be overridden to return a non-negative value if your layer expects some minimum number of bottom blobs. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1InfogainLossLayer.html#ad8a1ef702a695e379e5d0450369b4a0c">caffe::InfogainLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1RecurrentLayer.html#ac31b705bc02d333ae768f7c2184fbfae">caffe::RecurrentLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ScaleLayer.html#a12c10840f0fc3327854864a12054beb2">caffe::ScaleLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BiasLayer.html#ab75a2e05bbb1eb37bed5995288143f67">caffe::BiasLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1EltwiseLayer.html#a802079d89e0f007c15b39e0c1fb0d275">caffe::EltwiseLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1FilterLayer.html#af4c97961e859653ef0fa21d796af0259">caffe::FilterLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BaseConvolutionLayer.html#aa3d861ed15f6e41c6257d6a10defa7eb">caffe::BaseConvolutionLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ConcatLayer.html#a314de9eb00a296ffd3cf84120bd1601e">caffe::ConcatLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1SilenceLayer.html#af916fa4138f5d8761ec4490588eeccd1">caffe::SilenceLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a id="ab9e4c8d642e413948b131d851a8462a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e4c8d642e413948b131d851a8462a4">&sect;&nbsp;</a></span>MinTopBlobs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::MinTopBlobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum number of top blobs required by the layer, or -1 if no minimum number is required. </p>
<p>This method should be overridden to return a non-negative value if your layer expects some minimum number of top blobs. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1SoftmaxWithLossLayer.html#a9969336702fb1bbf31750629fb38fb45">caffe::SoftmaxWithLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1AccuracyLayer.html#a568dd59acff7a172fa614c88ac56aff7">caffe::AccuracyLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1HDF5DataLayer.html#a6833e081c29049b1392eb98fb4451697">caffe::HDF5DataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1DummyDataLayer.html#a2a63e36dd6b39287981d0bee466975aa">caffe::DummyDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InputLayer.html#a5d0512129e9c2955dde297a2f15595d2">caffe::InputLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1FilterLayer.html#af8c6eb9b1986e03dd14a907b5caa1324">caffe::FilterLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SliceLayer.html#a2673c06234a234362c1e2592880567a1">caffe::SliceLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1PoolingLayer.html#abb61ab67b2bd809c5633a2722b83feeb">caffe::PoolingLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BaseConvolutionLayer.html#ae4092cf1b48e18e5d82cd714ae6e8547">caffe::BaseConvolutionLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1DataLayer.html#ab0c5a7504085a6699272cdcfa8611887">caffe::DataLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1SplitLayer.html#a48dafac272f2f098798e3caa09afbabe">caffe::SplitLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a id="a1a3708013b0231e71d725252e10ce6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3708013b0231e71d725252e10ce6e3">&sect;&nbsp;</a></span>param_propagate_down()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::param_propagate_down </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>param_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies whether the layer should compute gradients w.r.t. a parameter at a particular index given by param_id. </p>
<p>You can safely ignore false values and always compute gradients for all parameters, but possibly with wasteful computation. </p>

</div>
</div>
<a id="a7fe981e8af8d93d587acf2a952be563d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe981e8af8d93d587acf2a952be563d">&sect;&nbsp;</a></span>Reshape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::Reshape </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust the shapes of top blobs and internal buffers to accommodate the shapes of the bottom blobs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bottom</td><td>the input blobs, with the requested input shapes </td></tr>
    <tr><td class="paramname">top</td><td>the top blobs, which should be reshaped as needed</td></tr>
  </table>
  </dd>
</dl>
<p>This method should reshape top blobs as needed according to the shapes of the bottom (input) blobs, as well as reshaping any internal buffers and making any other necessary adjustments so that the layer can accommodate the bottom blobs. </p>

<p>Implemented in <a class="el" href="classcaffe_1_1LSTMUnitLayer.html#a795bd455f4635e876de32323e9cee96d">caffe::LSTMUnitLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SoftmaxWithLossLayer.html#a2821b89b0f46a5e2ddaccb2708ab237b">caffe::SoftmaxWithLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InfogainLossLayer.html#a83ed478450bc7f629499fed37f654c5c">caffe::InfogainLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SigmoidCrossEntropyLossLayer.html#a305423abeea4bd1652ff7e696aaba808">caffe::SigmoidCrossEntropyLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1MultinomialLogisticLossLayer.html#a979be47987712c02dfb57a88b2a69f11">caffe::MultinomialLogisticLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BatchNormLayer.html#a1acd542fe8fe89d88db9050d048fc7d2">caffe::BatchNormLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1EuclideanLossLayer.html#a9cbe90ea0130c31bd5b9419a1bbaa555">caffe::EuclideanLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ArgMaxLayer.html#a291a2c548c28e7ab02ddac0cfd3cbdad">caffe::ArgMaxLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1PReLULayer.html#a50ad2070e060093556d1fc12f31e33b1">caffe::PReLULayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1DropoutLayer.html#a8ddbd583b7430f228506954910935505">caffe::DropoutLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BaseDataLayer.html#a2955d06a5e67609582fb293a0a37673f">caffe::BaseDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1HDF5OutputLayer.html#afaed17dc14251e627764334d54e55c4d">caffe::HDF5OutputLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1AccuracyLayer.html#aa2b680fc1e754440c2babd150e09f2f6">caffe::AccuracyLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1HDF5DataLayer.html#a38b8924648ba4ab2933fe389fa608cad">caffe::HDF5DataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1PythonLayer.html#aa6597e54cd5fea5b5c7b67299b74a72c">caffe::PythonLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1RecurrentLayer.html#aba6011a9cbb18e38a8596aa5dbb44723">caffe::RecurrentLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ScaleLayer.html#aeafe805a68903bae9a7f2b98bf453e22">caffe::ScaleLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LossLayer.html#abf00412194f5413ea9468ee44b0d986f">caffe::LossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LRNLayer.html#aa002dacb2f69d2b500227f938a957a81">caffe::LRNLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BiasLayer.html#aff9bd5f76055189c5ec66f43faf17660">caffe::BiasLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1DummyDataLayer.html#ae72f2ea80339981bf925f0291f62d527">caffe::DummyDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InputLayer.html#a4c2028f829734a202263725d8aa41152">caffe::InputLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1CropLayer.html#a195d2e437a70b0139411c1dd22b08120">caffe::CropLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1FlattenLayer.html#a3b459231a94176753d0cb1ae94bc942f">caffe::FlattenLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1EmbedLayer.html#ac7c19a708d491f9fe161c78348ec794b">caffe::EmbedLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1Im2colLayer.html#a119c9e1965e219be1ccb719821d4542f">caffe::Im2colLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ParameterLayer.html#acc7cf7e2dea7e254717b13980fdf6c1a">caffe::ParameterLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ReductionLayer.html#a0f6594ec41a0556e9fcfb9af0ae86c8a">caffe::ReductionLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BatchReindexLayer.html#a7f69b6b19387959bf0926dde7a7922a4">caffe::BatchReindexLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1EltwiseLayer.html#a17b4cb0842a154224bab9733e77e07b9">caffe::EltwiseLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1FilterLayer.html#ade673aa44e466adbe3aa79531a7c7484">caffe::FilterLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InnerProductLayer.html#a1c823624ec9286477db7caa5188152b8">caffe::InnerProductLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ReshapeLayer.html#a5b85ce44e23b4f958a60ff2b2c43e61f">caffe::ReshapeLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SliceLayer.html#af9fa49d54abf1cb090cfc772eb4acc4d">caffe::SliceLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SPPLayer.html#a3ba65e459c1bde4f772d545efb43a2f2">caffe::SPPLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BaseConvolutionLayer.html#aa215338f200c832081f2719a54bc5256">caffe::BaseConvolutionLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1PoolingLayer.html#ac652e08deffb0eeb6c3113abb55eb641">caffe::PoolingLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ConcatLayer.html#a3c7cbd500d3a15cfbdbf33479c4fb228">caffe::ConcatLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1NeuronLayer.html#a6d0facf4a5e6f459cf1cb8b28d945790">caffe::NeuronLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SplitLayer.html#a4e978965461dedcc2fbb905e4910c0b1">caffe::SplitLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1MVNLayer.html#a48aafabe729bb3b22171cfdbda6e6073">caffe::MVNLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SoftmaxLayer.html#a756fd5ad3af07d019b5f2247f38b4496">caffe::SoftmaxLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SilenceLayer.html#a96a47a49a103e60a681f97eff7bf42f2">caffe::SilenceLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1TileLayer.html#a593f5b8342f1b092633d2a1f7e4a6843">caffe::TileLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a id="a04eb2a3d1d59c64cd64c233217d5d6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04eb2a3d1d59c64cd64c233217d5d6fc">&sect;&nbsp;</a></span>SetLossWeights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::SetLossWeights </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>top</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called by SetUp to initialize the weights associated with any top blobs in the loss function. Store non-zero loss weights in the diff blob. </p>

</div>
</div>
<a id="a18d6bfdb535ab8e96a971dec4ae39a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d6bfdb535ab8e96a971dec4ae39a84">&sect;&nbsp;</a></span>SetUp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::SetUp </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements common layer setup functionality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bottom</td><td>the preshaped input blobs </td></tr>
    <tr><td class="paramname">top</td><td>the allocated but unshaped output blobs, to be shaped by Reshape</td></tr>
  </table>
  </dd>
</dl>
<p>Checks that the number of bottom and top blobs is correct. Calls LayerSetUp to do special layer setup for individual layer types, followed by Reshape to set up sizes of top blobs and internal buffers. Sets up the loss weight multiplier blobs for any non-zero loss weights. This method may not be overridden. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8073fcf2c139b47eb99ce71b346b1321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8073fcf2c139b47eb99ce71b346b1321">&sect;&nbsp;</a></span>blobs_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;shared_ptr&lt;<a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt;Dtype&gt; &gt; &gt; <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::blobs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The vector that stores the learnable parameters as a set of blobs. </p>

</div>
</div>
<a id="a7ed12bb2df25c887e41d7ea9557fc701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed12bb2df25c887e41d7ea9557fc701">&sect;&nbsp;</a></span>layer_param_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LayerParameter <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::layer_param_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The protobuf that stores the layer parameters </p>

</div>
</div>
<a id="af6d347229a139500994e7a926c680486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d347229a139500994e7a926c680486">&sect;&nbsp;</a></span>loss_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;Dtype&gt; <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::loss_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The vector that indicates whether each top blob has a non-zero weight in the objective function. </p>

</div>
</div>
<a id="acd4a05def9ff3b42ad72404210613ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4a05def9ff3b42ad72404210613ef7">&sect;&nbsp;</a></span>param_propagate_down_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;bool&gt; <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::param_propagate_down_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Vector indicating whether to compute the diff of each param blob. </p>

</div>
</div>
<a id="a1d04ad7f595a82a1c811f102d68b8a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d04ad7f595a82a1c811f102d68b8a19">&sect;&nbsp;</a></span>phase_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Phase <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::phase_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The phase: TRAIN or TEST </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/caffe/<a class="el" href="layer_8hpp_source.html">layer.hpp</a></li>
<li>src/caffe/layer.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 21 2016 11:23:43 for Caffe by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
